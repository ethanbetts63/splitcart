import os
import pprint
from products.models import Product

TRANSLATION_TABLE_PATH = os.path.join(os.path.dirname(__file__), '..', 'data', 'product_name_translation_table.py')

class TranslationTableGenerator:
    """
    A dedicated class for generating the translation table.
    """
    def __init__(self, command):
        self.command = command

    def generate(self):
        """
        Queries all products, builds a translation dictionary from their name variations,
        and overwrites the product_name_translation_table.py file.
        """
        self.command.stdout.write(self.command.style.SQL_FIELD("--- Regenerating product name translation table ---"))
        translations = {}
        all_products = Product.objects.all()

        for product in all_products:
            if not product.name_variations or not isinstance(product.name_variations, list):
                continue

            for variation_tuple in product.name_variations:
                if isinstance(variation_tuple, (list, tuple)) and len(variation_tuple) > 0:
                    variation_name = variation_tuple[0]
                    if variation_name.lower() != product.name.lower():
                        translations[variation_name] = product.name

        file_content = (
            "# This file is auto-generated by the TranslationTableGenerator.\n"
            "# Do not edit manually.\n\n"
            f"PRODUCT_NAME_TRANSLATIONS = {pprint.pformat(translations)}\n"
        )

        try:
            with open(TRANSLATION_TABLE_PATH, 'w', encoding='utf-8') as f:
                f.write(file_content)
            self.command.stdout.write(self.command.style.SUCCESS(f"Successfully regenerated translation table with {len(translations)} entries."))
        except IOError as e:
            self.command.stderr.write(self.command.style.ERROR(f"Could not write to translation table file: {e}"))
