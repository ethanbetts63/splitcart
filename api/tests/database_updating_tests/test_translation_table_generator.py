import unittest
from unittest.mock import patch, MagicMock, mock_open
from api.database_updating_classes.translation_table_generator import TranslationTableGenerator, TRANSLATION_TABLE_PATH
from products.models import Product

class TranslationTableGeneratorTests(unittest.TestCase):

    def setUp(self):
        self.mock_command = MagicMock()
        self.generator = TranslationTableGenerator(self.mock_command)

    @patch('api.database_updating_classes.translation_table_generator.Product.objects.all')
    @patch('builtins.open', new_callable=mock_open)
    def test_generate_creates_correct_table(self, mock_file, mock_get_products):
        """
        Test that the translation table is generated with the correct content.
        """
        # Arrange
        product1 = MagicMock()
        product1.normalized_name_brand_size = 'brandonecanonicalone'
        product1.normalized_name_brand_size_variations = ['variation-a', 'variation-b']

        product2 = MagicMock()
        product2.normalized_name_brand_size = 'brandtwocanonicaltwo'
        product2.normalized_name_brand_size_variations = ['variation-c', 'CANONICAL-TWO']

        mock_get_products.return_value = [product1, product2]

        # Act
        self.generator.generate()

        # Assert
        mock_file.assert_called_once_with(TRANSLATION_TABLE_PATH, 'w', encoding='utf-8')
        
        handle = mock_file()
        
        # Check that the header was written
        handle.write.assert_any_call("# This file is auto-generated by the TranslationTableGenerator.\n")
        handle.write.assert_any_call("# Do not edit manually.\n\n")
        handle.write.assert_any_call("PRODUCT_NAME_TRANSLATIONS = {\n")
        
        # Check that the translations were written correctly
        handle.write.assert_any_call("    'variation-a': 'brandonecanonicalone',\n")
        handle.write.assert_any_call("    'variation-b': 'brandonecanonicalone',\n")
        handle.write.assert_any_call("    'variation-c': 'brandtwocanonicaltwo',\n")
        
        # Check that the closing brace was written
        handle.write.assert_any_call("}\n")

    @patch('api.database_updating_classes.translation_table_generator.Product.objects.all')
    @patch('builtins.open', side_effect=IOError("Test error"))
    def test_generate_handles_io_error(self, mock_open, mock_get_products):
        """
        Test that an IOError during file writing is handled gracefully.
        """
        # Arrange
        mock_get_products.return_value = [MagicMock()]

        # Act
        self.generator.generate()

        # Assert
        self.mock_command.stderr.write.assert_called_once_with(self.mock_command.style.ERROR(f"Could not write to translation table file: Test error"))

if __name__ == '__main__':
    unittest.main()
