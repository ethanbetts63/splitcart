from itertools import combinations
from thefuzz import fuzz
from products.models import Product, ProductBrand, ProductSubstitution

class BaseSubstitutionGenerator:
    """
    Base class for different substitution generation strategies.
    """
    def __init__(self, command):
        self.command = command

    def generate(self):
        """The main method to find and create substitutions."""
        raise NotImplementedError("Subclasses must implement the 'generate' method.")

    def _create_substitution(self, product_a, product_b, type, score, source):
        """
        Creates a symmetrical substitution entry in the database, ensuring no duplicates.
        The product with the lower ID is always stored as product_a to prevent duplicates like (A,B) and (B,A).
        """
        if product_a.id == product_b.id:
            return None, False

        if product_a.id > product_b.id:
            product_a, product_b = product_b, product_a

        sub, created = ProductSubstitution.objects.update_or_create(
            product_a=product_a,
            product_b=product_b,
            defaults={
                'type': type,
                'score': score,
                'source': source
            }
        )
        return sub, created

class SizeSubstitutionGenerator(BaseSubstitutionGenerator):
    """
    Generates substitutions for Level 1: Same brand, same product, different size.
    This implementation now uses string similarity on normalized names to group products.
    """
    def generate(self):
        self.command.stdout.write("--- Generating Level 1: Size Substitutions (Similarity Method) ---")
        
        brands = ProductBrand.objects.all()
        new_substitutions_count = 0

        for brand in brands:
            # Eagerly load products to avoid N+1 queries
            products = list(Product.objects.filter(brand=brand.name))
            if len(products) < 2:
                continue

            # Group products by similarity of their normalized names
            similar_product_groups = self._group_by_similarity(products)

            for group in similar_product_groups:
                if len(group) > 1:
                    # Create substitutions for all pairs within the group
                    for prod_a, prod_b in combinations(group, 2):
                        _, created = self._create_substitution(
                            prod_a, 
                            prod_b, 
                            type='SIZE', 
                            score=0.95, 
                            source='size_similarity_v1'
                        )
                        if created:
                            new_substitutions_count += 1
        
        self.command.stdout.write(self.command.style.SUCCESS(f"Generated {new_substitutions_count} new size substitutions."))

    def _group_by_similarity(self, products):
        """
        Groups products by comparing the similarity of their normalized_name.
        This uses a clustering approach with a high similarity threshold.
        """
        groups = []
        for product in products:
            # The product's normalized_name is the key for comparison.
            # This field is generated by the model's save() method.
            if not product.normalized_name:
                continue

            placed_in_group = False
            for group in groups:
                # Compare the new product to the first product in an existing group.
                representative = group[0]
                
                # token_set_ratio is robust against different word order and extra words.
                similarity_score = fuzz.token_set_ratio(
                    product.normalized_name, 
                    representative.normalized_name
                )
                
                # A high threshold is used to ensure we're only grouping clear size variants.
                if similarity_score > 90:
                    group.append(product)
                    placed_in_group = True
                    break
            
            if not placed_in_group:
                # This product becomes the representative for a new group.
                groups.append([product])
        return groups