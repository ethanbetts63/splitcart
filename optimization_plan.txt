# Optimization Logic Plan v1

This document outlines the plan for the core optimization engine, which calculates the cheapest possible shopping cart for a user based on their list, preferences, and available substitutions.

---

### 1. The Core Problem

The goal is to take a user's shopping list, a list of acceptable substitutes for each item, and a set of preferred stores, and determine the ideal combination of purchases to minimize the total cost.

This will be solved using the `pulp` Python library for linear programming, adapted from the initial `splitcart_concept.py` script.

---

### 2. The "Pre-Filtering" User Flow

To simplify the final optimization problem and improve the user experience, a "pre-filtering" approach will be implemented throughout the user's journey. This is a critical design decision.

1.  **Establish "Store Context" First:** At the beginning of a session, the user will define their shopping constraints (e.g., by selecting preferred stores or defining a travel radius). This establishes a "Store Context" for all subsequent actions.

2.  **Filtered Search:** When the user searches for products, the API will only return results that are available within the established Store Context.

3.  **Filtered Substitutions:** When the application suggests substitutes for an item, the suggestions will also be pre-filtered to only include products available in the user's chosen stores.

**Benefit:** This approach ensures that the data passed to the final optimization engine is already clean, relevant, and possible to purchase. It avoids the complexity of handling item unavailability at the optimization stage and prevents showing the user items they cannot buy.

---

### 3. The Input Data Structure: "Shopping Slots"

The input for the optimization function will not be a flat list of products. Instead, it will be a "list of lists," referred to as `shopping_slots`.

*   **Structure:** `shopping_slots = [[product_A], [product_B, product_C], ...]`
*   **Representation:** Each inner list represents a single "slot" on the user's shopping list (e.g., "milk," "bread").
*   **Contents:** The inner list contains all products the user has deemed acceptable for that slot: the original item plus any approved substitutes.

---

### 4. Adapting the PuLP Optimization Model

The existing PuLP script will be evolved to handle the `shopping_slots` structure. The key modification is to the central constraint.

*   **Old Constraint:** "For each `item` in the shopping list, buy it exactly once."

*   **New Core Constraint:** "For each `slot` in `shopping_slots`, choose and buy exactly ONE product from the list of acceptable products within that slot."

This will be implemented in PuLP like so:

```python
# For each slot in our list of shopping_slots...
for slot in shopping_slots:

    # Sum the purchase decisions for all acceptable products within this slot.
    # By setting the sum == 1, we force the optimizer to choose exactly one.
    prob += (
        pulp.lpSum(
            product_assignments[product][store]
            for product in slot
            for store in available_stores # These are the user's chosen stores
        )
        == 1
    ), f"Satisfy_slot_{slot_identifier}"
```

The other constraints (e.g., maximum number of stores to visit) and the objective function (minimize total cost) will remain conceptually the same as in the original proof-of-concept script.
