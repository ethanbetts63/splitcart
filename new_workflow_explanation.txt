# Detailed Workflow of the Refactored Database Update Process

This document outlines the step-by-step journey of product data through the new object-oriented update system.

### Core Components

- **UpdateOrchestrator:** The main controller that manages the overall process flow.
- **ProductResolver:** A read-only service that holds a snapshot of the database state for fast lookups.
- **UnitOfWork:** A service that collects all proposed database changes (creations, updates) and commits them in a single, atomic transaction.
- **CategoryManager:** A sub-service used by the UnitOfWork to handle all category and product-relationship logic.
- **VariationManager:** A service that handles the detection of name variations and the post-commit reconciliation of duplicate products.
- **TranslationTableGenerator:** A final-step service to generate the (currently unused) translation table.

--- 

### Phase 1: Initiation & Caching (The Snapshot)

1.  **Command Start:** The `python manage.py update_db --products` command is executed.
2.  **Orchestrator Init:** The command's `handle` method creates a single instance of `UpdateOrchestrator`.
3.  **Build Caches:** The orchestrator immediately instantiates `ProductResolver`. The resolver's `__init__` method runs, building several in-memory caches by querying the database **once** at the start. This creates a complete, static snapshot of the database state. The caches include:
    - All product barcodes.
    - All store-specific product IDs.
    - All normalized name strings.
    - All `Store` objects.
    - All existing `Price` records (keyed by product, store, and date).

--- 

### Phase 2: File Processing & In-Memory Consolidation

4.  **File Iteration:** The `UpdateOrchestrator` begins looping through each `.jsonl` file in the product inbox.
5.  **Data Consolidation:** For each file, it reads all lines into memory. It then consolidates the multiple raw product entries into a single, rich `consolidated_data` dictionary. This groups all prices and details for a unique product (keyed by its `normalized_name_brand_size`) within that file.

--- 

### Phase 3: Product Identification & Change Collection

6.  **Identify Products:** The orchestrator loops through the `consolidated_data` dictionary. For each unique product, it asks the `ProductResolver` to find a match against the initial database snapshot.
7.  **Decision Making:**
    - **If a match IS found:** The product is considered **existing**.
        - The orchestrator checks for name variations using the `VariationManager`.
        - It checks the `ProductResolver`'s price cache. For any prices that don't already exist, it creates new `Price` objects and adds them to the `UnitOfWork`.
    - **If no match is found:** The product is considered **new**.
        - A new `Product` object is created.
        - This new `Product` object is added to the `UnitOfWork`'s list of products to be created.
        - New `Price` objects are created and added to the `UnitOfWork`.

--- 

### Phase 4: The Atomic Commit (The Transaction)

8.  **Commit Trigger:** After a file is fully processed, the orchestrator calls `unit_of_work.commit()`.
9.  **Inside the Transaction:** The `commit` method executes the following steps inside a single, all-or-nothing database transaction:
    a.  **De-duplication:** It takes the list of potentially new products and de-duplicates it. It checks against the resolver's initial cache AND against itself to ensure no two products in the batch share a unique key (like barcode). This prevents `UNIQUE constraint` errors.
    b.  **Create Products:** It performs a `bulk_create` on the now truly unique list of new products.
    c.  **Process Categories:** It calls the `CategoryManager`, which performs its three-part process:
        i.  Finds and bulk-creates any new category names.
        ii. Creates parent-child relationships for the category hierarchy.
        iii. Bulk-creates the links between all products and their categories.
    d.  **Create Prices:** It performs a `bulk_create` for all new `Price` objects collected.
    e.  **Update Products:** It performs a `bulk_update` for any existing products that had name variations added.
10. **Transaction End:** If any step fails, the entire transaction is rolled back, and the database is left untouched. If it succeeds, the changes are saved.

--- 

### Phase 5: Post-Commit Cleanup & Reconciliation

11. **File Cleanup:** If the commit was successful, the orchestrator deletes the `.jsonl` file it just processed.
12. **Hotlist & Reconciliation:** After all files have been processed, the orchestrator calls the `VariationManager` to:
    a.  Write all the discovered name variations from the entire run to the `name_variation_hotlist.json` file.
    b.  Read the hotlist, find any duplicate products in the database, and merge them.
13. **Generate Translations:** As the final step, the `TranslationTableGenerator` is called to regenerate the `product_name_translation_table.py` file.
