### Session Summary: Refactoring the Substitution Workflow

**Objective:** The primary goal of this session is to fully refactor the product substitution workflow, integrating it with the new `CartContext` and ensuring a seamless data flow from the moment an item is added to the cart to the final optimization step.

**Analysis of the Current State:**

1.  **Obsolete Frontend:** The `SubstitutionPage.tsx` is currently non-functional as it relies on the old, now-defunct `SubstitutionContext`.
2.  **Backend Expectation:** The backend `CartOptimizationView` requires a specific data structure for its `cart` parameter: a "list of lists," where each inner list represents a product slot containing the original item and any user-approved substitutes.
3.  **The Gap:** A disconnect exists between the frontend's ability to gather user approvals for substitutes and the backend's required data format. The logic to construct and send this payload is missing.

**The New "Fetch-on-Add" Architecture:**

To create an efficient and seamless user experience, we will implement a "Fetch-on-Add" strategy. This means that all potential substitute options for a product will be fetched automatically in the background at the moment a user adds that product to their cart. This ensures all necessary data is pre-loaded and available before the user even reaches the `SubstitutionPage`.

**Detailed Implementation Plan:**

1.  **Enhance `CartContext.tsx`:** The context will be updated to manage the fetching and storage of potential substitutes.
    *   **New State:** A new state variable, `potentialSubstitutes`, will be added. It will be an object that maps an original product's ID to an array of its potential substitute products.
    *   **Modify `addItem` Function:** The `addItem` function will be updated. After successfully adding an item to the cart, it will trigger a second, background API call to fetch the substitutes for that specific product. The results will be stored in the new `potentialSubstitutes` state.
    *   **Expose Data:** The `potentialSubstitutes` object will be exposed through the `useCart` hook for consumption by other components.

2.  **Refactor `SubstitutionPage.tsx`:** This page will be rebuilt to work within the new system.
    *   **Integrate `useCart`:** All dependencies on the old `SubstitutionContext` will be removed. The component will use the `useCart` hook to access the `currentCart` (for original items) and the pre-fetched `potentialSubstitutes`.
    *   **Manage Approved Selections:** The page will use its own **local state** to track which of the potential substitutes the user has explicitly **approved**. This is a crucial distinction to separate user choice from mere options.

3.  **Implement the Optimization API Call:** The final step on the `SubstitutionPage` will be to communicate with the backend.
    *   **Build Payload:** When the user proceeds to the final step, a new function will be triggered. This function will read the original items from `currentCart` and the user-approved substitutes from the page's local state.
    *   **Format Data:** It will construct the final payload, including the critical "list of lists" `cart` structure required by the `CartOptimizationView`.
    *   **API Request:** It will then `POST` this payload to the `/api/cart/split/` endpoint.
    *   **Handle Response:** The optimization results returned from the backend will be stored in a new state (likely within the `CartContext`) before navigating the user to the final results page.

**Expected Outcome:** This refactoring will result in a fully functional, efficient, and user-friendly substitution and optimization workflow that is seamlessly integrated with the new cart management system.