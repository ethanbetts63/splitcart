  Session Summary

  Objective: The primary goal of this session was to diagnose and resolve significant performance issues related to the application's
  initial load time and data fetching strategies.

  Work Completed:

   1. Centralized Data Fetching: We began by identifying redundant data fetching logic across several frontend components. To solve
      this, we created a centralized useApiQuery custom hook that standardizes all API requests, handles authentication, and leverages
      the caching power of react-query. We then refactored CategoryBar, ProductCarousel, and GridSourcer to use this new, simpler hook.

   2. Image Caching: We diagnosed why product images in the shopping cart were not being cached. We found that the CartItemTile
      component was not using our useImageAsset hook. We corrected this, ensuring that images, once loaded, are served instantly from an
       in-memory cache.

   3. Backend Performance Optimization: We identified that the /api/initial-setup/ endpoint was a major performance bottleneck. After
      analyzing the code, we discovered a severe "N+1 query problem" was causing dozens of unnecessary database queries. We fixed this
      by implementing an efficient, batch-fetching strategy: the view now pre-fetches all required price data in a single query and
      passes it directly to the serializer, dramatically speeding up the API response time.

   4. Frontend Code Splitting: To further improve load times, we implemented route-based code splitting. By using React.lazy, we broke
      the main JavaScript bundle into smaller chunks. Now, the browser only downloads the code for the specific page the user is
      visiting, which results in a much smaller initial download and a faster "time to first paint."

  Current Task & Next Steps

  We are currently in the middle of implementing the final and most impactful performance optimization: eliminating the initial data
  request from the browser entirely by embedding the data in the initial HTML payload.

  Current Progress:
   * We have created a new Django view (ReactAppView) that will be responsible for serving the React application.
   * We have configured Django's main urls.py with a catch-all route to direct all non-API requests to this new view.
   * We have created a Django-compatible index.html template that will serve as the entry point for the React app.

  Immediate Next Steps:
   1. Configure Static Files: I will modify settings.py to teach Django where to find the JavaScript and CSS files that are generated
      when the React application is built.
   2. Embed Data in the View: I will add the data-loading logic to our new ReactAppView. It will run the initial-setup logic on the
      server and prepare the data to be passed to the template.
   3. Update the Template: I will modify templates/index.html to take the data from the view and embed it into a global
      window.__INITIAL_DATA__ JavaScript variable.
   4. Update the Frontend: Finally, I will change the logic in main.tsx to read from this window.__INITIAL_DATA__ variable instead of
      making a fetch request, which will complete the optimization.