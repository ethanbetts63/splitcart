  ### Core Responsibilities of the Database Update Process

  Here is a step-by-step breakdown of the system's current
  functionality, from reading the inbox files to the final cleanup:


  1. Data Aggregation & In-Memory Consolidation
  *   It reads one .jsonl file from the inbox at a time.
  *   It processes the file line-by-line, consolidating multiple scraped
   entries for the same product (identified by barcode or name) into a
  single, more complete in-memory object. This happens *before* any
  database checks.
  *   It collects all associated price points, name variations, and
  other details for each unique product within that file.


  2. Database State Caching
  *   Before checking for products, it pre-fetches and caches critical
  database information for fast, in-memory lookups. This includes:
         Barcode Cache*: A dictionary mapping every existing barcode to
  its Product object.
         Store Product ID Cache*: A dictionary mapping (store_id,
  store_product_id) tuples to their Product objects.
         Normalized String Cache*: A dictionary mapping
  normalized_name_brand_size strings to their Product objects.


  3. Product Matching & Resolution (The 3-Tier System)
  *   For each consolidated product from the inbox file, it attempts to
  find a match in the database using the caches, in this specific order
  of priority:
         Tier 1 (Highest):* By barcode.
         Tier 2:* By (store_id, store_product_id).
         Tier 3 (Fallback):* By normalized_name_brand_size.


  4. Entity State Management
     For Existing Products:* If a match is found, it identifies the
  incoming data as an update to an existing Product.
     For New Products:* If no match is found after checking all three
  tiers, it identifies the incoming data as a completely new Product.


  5. Name Variation & Synonym Handling
     Detection:* When a barcode match occurs (Tier 1), it specifically
  checks if the incoming brand or name differs from the existing
  product's data.
     Updating the Product:* If a name variation is found, it appends the
   new (name, company) tuple to the name_variations list on the existing
   Product object.
     Hotlist Logging:* It creates an entry in the
  name_variation_hotlist.json file, recording the canonical name, the
  new variation, and the shared barcode. This flags the event for later
  reconciliation.
     Synonym Discovery:* It performs a similar check for brand names and
   logs potential brand synonyms separately.


  6. Batch Database Operations
  *   The system does not perform database writes one-by-one. It
  collects all changes in memory first.
  *   It creates lists of new Product objects, new Price objects, and
  new category relationships.
  *   It uses Django's bulk_create to insert all new products and prices
   in efficient, atomic batches.
  *   It uses bulk_update to save changes to existing products (like the
   name_variations list).


  7. Post-Update Reconciliation (Merging Duplicates)
     This phase runs only once*, after all files in the inbox have been
  processed.
     Hotlist Analysis:* It reads the entire name_variation_hotlist.json.
     Duplicate Finding:* It queries the database to find the Product
  objects corresponding to the "canonical" and "variation" names from
  the hotlist, creating pairs of products to be merged.
     Conflict Prevention:* It includes a critical sanity check to
  prevent merging products that have different barcodes, logging these
  conflicts to a file for manual review instead.
     Merging Logic:* For valid pairs, it performs an atomic merge:
      1.  It reassigns all Price records from the duplicate product to
  the canonical one.
      2.  It deletes the now-empty duplicate Product.
     Cleanup:* It clears the name_variation_hotlist.json file, preparing
   it for the next run.


  8. Translation Table Generation
  *   As the absolute final step, it queries the database for all
  products that have entries in their name_variations field.
  *   It builds a dictionary mapping every variation name to its
  canonical product name.
  *   It overwrites the product_name_translation_table.py file with this
   dictionary.
