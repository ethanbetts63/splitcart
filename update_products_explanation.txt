This document breaks down the functionality of the `python manage.py update --products` command, explaining each class involved in the process of taking raw product data from .jsonl files and committing it to the database.

### `Command` (data_management/management/commands/update.py)

This file defines the `update` management command, which serves as the main entry point for various data update processes. When executed with the `--products` flag, it initiates the product and price update workflow. Its primary responsibility in this context is to instantiate and trigger the `UpdateOrchestrator`, passing it the path to the `product_inbox` directory where new, unprocessed `.jsonl` data files are stored. It acts as the top-level controller that kicks off the entire complex update procedure.

### `UpdateOrchestrator` (data_management/database_updating_classes/update_orchestrator.py)

The `UpdateOrchestrator` is the central conductor of the product update process. It iterates through each `.jsonl` file in the `product_inbox`. For each file, it consolidates the raw product data, fetches the relevant `Company` and `Store` objects, and then instantiates the necessary services for that file's context, including the `ProductResolver`, `UnitOfWork`, and `BrandManager`. It methodically processes each product within the file, deciding whether it's a new product or an update to an existing one. After all files are processed, it orchestrates a series of post-processing steps, including running the `GroupOrchestrator` to infer prices, regenerating translation tables for name variations, and running reconciliation services to merge duplicate products and brands. Finally, it cleans up by deleting the processed `.jsonl` files from the inbox.

### `ProductResolver` (data_management/database_updating_classes/product_resolver.py)

The `ProductResolver` is a crucial optimization component responsible for efficiently matching incoming product data with existing records in the database. When instantiated by the `UpdateOrchestrator` for a specific file, it pre-emptively loads all products, prices, and stores into several in-memory caches (or dictionaries). These caches are indexed by different keys: barcode, store-specific SKU, and a normalized name-brand-size string. It then provides a `find_match` method that implements a three-tier matching logic (checking barcode first, then SKU, then the normalized string) to quickly find an existing product without needing to query the database for every single incoming item. This dramatically speeds up the process of identifying whether a product is new or pre-existing.

### `UnitOfWork` (data_management/database_updating_classes/unit_of_work.py)

The `UnitOfWork` class is responsible for managing all database changes within a single, atomic transaction for a given `.jsonl` file. Instead of writing to the database one by one, it collects all proposed changes—new products to be created, existing products to be updated, and new prices to be added. Once all products in a file have been processed, its `commit` method executes the database operations in an efficient, ordered manner using `bulk_create` and `bulk_update`. This approach provides a significant performance boost and ensures data integrity; if any part of the process fails for a given file, the entire transaction is rolled back, leaving the database in its original state and preventing partial updates. It also coordinates with the `CategoryManager` to handle category assignments within the same transaction.

### `VariationManager` (data_management/database_updating_classes/variation_manager.py)

The `VariationManager` is responsible for identifying and recording differences between incoming product data and existing product records, specifically for product names and brands. When the `UpdateOrchestrator` finds a match for an incoming product, it invokes this manager. The `VariationManager` compares the incoming product's name and brand against the existing record's canonical name and brand. If it discovers a new variation (e.g., "Coke" vs. "Coca-Cola"), it adds the new name to a JSON list of variations on the existing product or brand record. This ensures that alternative names are captured without creating duplicate master records, and the changes are passed to the `UnitOfWork` to be included in the database update.

### `BrandManager` (data_management/database_updating_classes/brand_manager.py)

The `BrandManager` is responsible for creating and managing canonical `ProductBrand` records. For each product being processed, the `UpdateOrchestrator` calls this manager, which maintains an in-memory cache of brand objects to avoid redundant database queries. It uses a normalized version of the brand name as a unique key to find or create a single, canonical entry for each brand (e.g., ensuring "Coca-Cola" and "coca cola" resolve to the same record). It also identifies when a raw brand name from the scraped data is a new variation of an existing canonical brand, collecting these variations. At the end of processing a file, its `commit` method performs a `bulk_update` to save all the newly discovered brand name variations to the database.

### `CategoryManager` (data_management/database_updating_classes/category_manager.py)

The `CategoryManager` is responsible for all aspects of handling product categories within the `UnitOfWork`'s transaction. Its main `process_categories` method orchestrates a three-part process. First, it collects all unique category paths (e.g., ["Bakery", "Bread", "Rolls"]) from the incoming data and bulk-creates any category names that don't already exist for the given company. Second, it establishes the hierarchical parent-child relationships between these categories. Third, it links each product to its appropriate leaf category. The manager uses a comprehensive in-memory cache of existing categories to minimize database queries and efficiently determines which new categories and relationships need to be created.

### `GroupOrchestrator` (data_management/database_updating_classes/group_orchestrator.py)

The `GroupOrchestrator` is a post-processing service that runs after product data has been committed. Its purpose is to leverage the concept of `StoreGroup`s—clusters of stores (like IGA or Foodland) that are expected to have identical pricing. For any group where at least one store was freshly scraped (a "candidate"), this orchestrator compares its prices to the group's designated "ambassador" store. If the prices match above a certain threshold, the group is considered healthy. The orchestrator then performs a key function: it infers prices for all *other* non-scraped stores in that group, creating new `Price` records for them based on the ambassador's data. This multiplies the value of a single scrape. If prices don't match, it can trigger a "divergence," outcast the rogue store, or even dissolve the group, thus maintaining data integrity.

### `BrandTranslationTableGenerator` (data_management/database_updating_classes/brand_translation_table_generator.py)

The `BrandTranslationTableGenerator` is a post-processing utility that creates a static Python file (`brand_translation_table.py`). This file contains a single dictionary, `BRAND_NAME_TRANSLATIONS`. The generator queries all `ProductBrand` records in the database and inspects their `normalized_name_variations` list. It then creates a mapping from each variation (the synonym) to the brand's canonical normalized name. This generated file serves as a fast, importable lookup table for the `BrandReconciler`, allowing it to quickly determine the correct canonical brand for a given variation without needing to query the database repeatedly.

### `ProductTranslationTableGenerator` (data_management/database_updating_classes/product_translation_table_generator.py)

The `ProductTranslationTableGenerator` is a post-processing utility that mirrors the functionality of the brand equivalent but for products. It creates a static Python file (`product_translation_table.py`) containing a dictionary named `PRODUCT_NAME_TRANSLATIONS`. The generator iterates through all `Product` records and reads their `normalized_name_brand_size_variations` list. It then builds a mapping from each variation string to the product's canonical `normalized_name_brand_size` string. This provides the `ProductReconciler` with a fast, importable lookup table to efficiently identify which products are duplicates and should be merged.

### `ProductReconciler` (data_management/database_updating_classes/product_reconciler.py)

The `ProductReconciler` is a critical post-processing service that cleans up duplicate `Product` records. It runs after the translation tables have been generated. It imports the `PRODUCT_NAME_TRANSLATIONS` dictionary and iterates through it, treating each key as a potential duplicate product's unique identifier. For each duplicate found, it identifies the corresponding canonical product. It then performs a merge operation: it enriches the canonical product with any missing information (like a URL or description) from the duplicate, moves all associated `Price` records from the duplicate to the canonical product, and finally deletes the now-redundant duplicate product record. This ensures that the database remains clean and that each unique product is represented by a single, canonical entry.

### `BrandReconciler` (data_management/database_updating_classes/brand_reconciler.py)

The `BrandReconciler` is a post-processing service that cleans up duplicate `ProductBrand` records, operating similarly to the `ProductReconciler`. It loads the `BRAND_NAME_TRANSLATIONS` dictionary and uses it to identify `ProductBrand` records that are considered duplicates of a canonical brand. For each duplicate brand found, it performs a merge within a database transaction. It reassigns all `Product`s associated with the duplicate brand to the canonical brand. It also merges any name variation lists from the duplicate into the canonical record. Finally, after the products have been reassigned, it deletes the now-obsolete duplicate brand record, ensuring a clean and canonical set of brands.

### `CategoryCycleManager` (data_management/database_updating_classes/category_cycle_manager.py)

The `CategoryCycleManager` is a final, crucial cleanup utility that runs at the very end of the update process. Its sole purpose is to ensure the integrity of the category hierarchy by detecting and fixing cyclical relationships. A cycle occurs if a category is, through a chain of parent-child relationships, its own ancestor (e.g., 'A' is a parent of 'B', 'B' is a parent of 'C', and 'C' is a parent of 'A'). Such cycles can cause infinite loops in queries or data processing. The manager traverses the category tree for each company and, if it detects that a parent node is already in the current traversal path, it identifies this as a cycle and automatically prunes the invalid relationship, logging that a repair was made.


## Execution Order

The process executes in a clear sequence with distinct loops. First, the `Command` is called once. This triggers the `UpdateOrchestrator`, which is also called once. The orchestrator then begins its main loop, iterating over each `.jsonl` file in the inbox. Inside this file loop, `ProductResolver`, `UnitOfWork`, and `BrandManager` are each instantiated once per file. The orchestrator then starts an inner loop over every product within the current file. During this product loop, `VariationManager` is called for each product to check for name or brand variations. After the product loop finishes, the `UnitOfWork` commits the changes for the file, which in turn calls the `CategoryManager` once to process all categories for that file. After the main file loop is complete, a series of single-call, post-processing classes are executed in order: `GroupOrchestrator`, `BrandTranslationTableGenerator`, `ProductTranslationTableGenerator`, `ProductReconciler`, and `BrandReconciler`. Finally, the `CategoryCycleManager` is called, which loops internally over each company to perform its checks.
