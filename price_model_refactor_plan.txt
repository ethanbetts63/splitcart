# Database Refactor Plan: Price Model Optimization

## 1. Objective

The goal is to reduce the storage space consumed by the `products_price` table without significantly increasing query complexity or sacrificing query performance. The current model stores a lot of redundant data when a product's price details remain unchanged over multiple days.

## 2. Current Model

The existing `Price` model has a structure similar to this:

- `product` (ForeignKey to Product)
- `store` (ForeignKey to Store)
- `price` (DecimalField)
- `is_on_special` (BooleanField)
- `is_available` (BooleanField)
- `scraped_at` (DateField)

This results in one row per product, per store, per day, with all the price details duplicated if they don't change.

## 3. Proposed New Model

This plan introduces a new `PriceDetail` model and refactors the existing `Price` model to point to it. This separates the frequently duplicated data from the unique daily records.

### New `PriceDetail` Model

Create a new table `products_pricedetail` with the following fields. This table will only store *unique* combinations of price details.

- `id` (Primary Key)
- `price` (DecimalField)
- `is_on_special` (BooleanField)
- `is_available` (BooleanField)

### Modified `Price` Model

The existing `products_price` table will be modified to be "thinner":

- `id` (Primary Key)
- `product` (ForeignKey to Product)
- `store` (ForeignKey to Store)
- `scraped_at` (DateField)
- `price_detail` (ForeignKey to the new `PriceDetail` model)

## 4. How It Works

The data update process would be a two-step operation:

1.  **Get or Create the PriceDetail:** When a new price is scraped, the system will first look for a `PriceDetail` object that exactly matches the scraped details (e.g., price=9.50, is_on_special=True). If one exists, it uses it. If not, it creates a new one.
2.  **Create the Price Record:** The system then creates a new `Price` object as it always has, but instead of storing the price details directly, it sets its `price_detail` foreign key to the object from step 1.

## 5. Advantages of This Approach

- **Significant Space Savings:** It avoids duplicating the actual price values and booleans. If a price is stable for a year, 365 `Price` rows will all point to a single `PriceDetail` row.
- **Maintains Query Performance:** Crucially, the main `Price` table still contains `product`, `store`, and `date`. This means common queries (e.g., "find all prices for this product over time") remain simple, fast, and easy to index.
- **Low Complexity:** The logic is straightforward to implement (`get_or_create` then `create`) and avoids the complex queries and updates required by a Many-to-Many date-linking approach.
