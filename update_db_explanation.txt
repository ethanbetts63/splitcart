# update_db Workflow Explanation

This document provides a verified explanation of the `update_db --products` command's workflow, based on the current codebase.

## Overall Process

The process is managed by the `UpdateOrchestrator`, which iterates through `.jsonl` files in the `product_inbox`, processes them one by one, and commits the changes to the database in a transactional manner.

### Phase 1: File-by-File Processing Loop

1.  **Initiation:** The `update_db --products` command is run.
2.  **File Discovery:** The `UpdateOrchestrator` finds all `.jsonl` files in the `product_inbox`.
3.  **Looping:** It processes one file at a time.

### Phase 2: Per-File Initialization & Consolidation

1.  **Service Instantiation:** For each file, new instances of `ProductResolver`, `UnitOfWork`, and `VariationManager` are created.
2.  **Cache Building:** The `ProductResolver` builds in-memory caches of products, prices, and stores for fast lookups.
3.  **Data Consolidation:** The `UpdateOrchestrator` reads the file and consolidates the data, using `normalized_name_brand_size` as a unique key to ignore duplicate product entries within the same file.

### Phase 3: Product Identification & Change Collection

1.  **Product Matching:** The `ProductResolver` attempts to match each product in the consolidated data to an existing product in the database using a 3-tier logic (barcode, store product ID, normalized string).
2.  **Change Collection:**
    *   **Existing Product:** If a match is found, the `VariationManager` checks for name variations, and a new price is added to the `UnitOfWork`.
    *   **New Product:** If no match is found, a new `Product` object is created and passed to the `UnitOfWork` along with its price data.

### Phase 4: The Atomic Commit

1.  **Transaction:** The `UnitOfWork.commit()` method is called, which wraps all database operations in a single atomic transaction.
2.  **Order of Operations:**
    a.  New products are de-duplicated.
    b.  New products are created in bulk (`bulk_create`).
    c.  Prices for the new products are prepared.
    d.  All new prices (for both new and existing products) are created in bulk.
    e.  Categories are processed and linked to products.
    f.  Existing products are updated in bulk (`bulk_update`) with any new information (e.g., name variations).

### Phase 5: Post-Run Cleanup & Finalization

1.  **File Cleanup:** After a file is successfully processed, it is moved to the `temp_product_storage` directory. This is a temporary measure during development to avoid re-scraping.
2.  **Translation Table Generation:** After all files have been processed, the `TranslationTableGenerator` runs to create a translation table for product name variations.

## Discrepancies and Unfinished Features

### Variation Reconciliation

- **Status:** **Disabled**
- **Description:** The `final_workflow_explanation.txt` document describes a step where a `VariationManager` reconciles and merges duplicate products after all files have been processed. However, the call to the `reconcile_duplicates()` method in the `UpdateOrchestrator` is currently **commented out**.
- **Reason:** This feature is not yet complete. The logic for merging duplicate products is still under development and has been disabled to prevent unintended side effects.


## Updates and Clarifications (Based on Recent Changes)

This section provides updates to the workflow description to reflect recent changes and new features implemented in the codebase.

### Phase 3: Product Identification & Change Collection (Updated)

- **Existing Product:** If a match is found, the `VariationManager` checks for name variations. Additionally, the existing product record is now intelligently enriched. Any blank fields (e.g., `barcode`, `url`, `image_url`, `description`, `country_of_origin`, `ingredients`) are filled with new information from the scraped file. For descriptions, the shorter value is preferred. If the product is from Coles and has no barcode, its `has_no_coles_barcode` flag is set to `True`.
- **New Product:** If no match is found, a new `Product` object is created. For Coles products without a barcode, the `has_no_coles_barcode` flag is set to `True` on creation.

### Phase 4: The Atomic Commit - Order of Operations (Updated)

- **f. Existing products are updated in bulk:** The `bulk_update` operation now includes a broader set of fields beyond just `name_variations`. These include `barcode`, `url`, `image_url`, `description`, `country_of_origin`, `ingredients`, `has_no_coles_barcode`, and `normalized_string_variations`.

### Variation Reconciliation (Updated Status)

- **Status:** **Replaced by New System**
- **Description:** The old `reconcile_duplicates()` method is disabled. It has been replaced by a new, robust reconciliation system. This new system is implemented as a separate management command (`reconcile_products`) and uses a precise translation table based on unique normalized strings (`variation_normalized_string` to `canonical_normalized_string`) to find and merge duplicates. This new system is designed to be run independently to clean up the database.

### New Product Model Fields

- `has_no_coles_barcode`: A boolean field to mark products confirmed to have no barcode from Coles.
- `normalized_string_variations`: A JSON field to store unique normalized strings of product name variations, used for the new reconciliation system.

### Data Pipeline Corrections

- The `ProductNormalizer` no longer performs pre-emptive name translation. This allows products with name variations to be created as distinct items, which are then handled by the new reconciliation system.
- The `prefill_barcodes_from_db` function was rewritten to correctly use the new normalized string-based translation table for looking up existing products, ensuring consistency across the data flow.