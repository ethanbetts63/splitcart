# OOP Refactor Plan for Database Update Process

This document outlines the proposed class structure for refactoring the utility-based database update logic into a more object-oriented system.

## Core Classes

### 1. `UpdateOrchestrator`
- **Role:** The main entry point and controller of the entire process.
- **Responsibilities:**
    - Replaces the `handle()` method of the `update_db` management command.
    - Iterates through files in the product inbox.
    - Initializes and coordinates the other classes (Resolver, UnitOfWork, VariationManager).
    - Manages the overall flow: Process File -> Finalize Batch -> Reconcile Variations.

### 2. `ProductResolver`
- **Role:** Handles all logic related to matching incoming products with existing database records.
- **Responsibilities:**
    - On initialization, it builds and holds the database caches (barcode, store_product_id, normalized_string).
    - Provides a single public method, e.g., `find_match(product_data)`, which implements the 3-tier matching logic.
    - Returns an existing `Product` object if a match is found, otherwise returns `None`.
    - Manages the state of the caches internally.

### 3. `UnitOfWork`
- **Role:** Manages database transactions and batch operations.
- **Responsibilities:**
    - Collects new objects that need to be created (Products, Prices, Category relationships).
    - Collects existing objects that need to be updated (e.g., Products with new name variations).
    - Provides methods like `add_new_product(obj)`, `add_new_price(obj)`, `add_for_update(obj)`.
    - Has a `commit()` method that executes the `bulk_create` and `bulk_update` queries within a single database transaction. This ensures atomicity.

### 4. `VariationManager`
- **Role:** Centralizes all logic for handling product name and brand variations.
- **Responsibilities:**
    - **Detection:** Provides a method, e.g., `check_for_variation(incoming_data, existing_product)`, that compares names/brands and updates the `name_variations` field on the existing product object.
    - **Hotlist Management:** Manages writing new variation entries to the `name_variation_hotlist.json` file. Could have a `HotlistWriter` helper class.
    - **Reconciliation:** Contains the logic for the post-update merge process.
        - Reads the hotlist.
        - Finds duplicate pairs in the database.
        - Performs barcode conflict checks.
        - Instructs the `UnitOfWork` or directly performs the merge (re-assigning prices and deleting the duplicate).
        - Clears the hotlist.

### 5. `TranslationTableGenerator`
- **Role:** A dedicated class for the final, separate step of generating the translation table.
- **Responsibilities:**
    - Queries the database for all products with name variations.
    - Builds the translation dictionary.
    - Writes the `product_name_translation_table.py` file.

## Example Workflow (Simplified)

1. `update_db` command creates an `UpdateOrchestrator` instance.
2. `UpdateOrchestrator` creates instances of `ProductResolver`, `UnitOfWork`, and `VariationManager`.
3. For each file in the inbox:
    - `UpdateOrchestrator` reads and consolidates the data.
    - For each consolidated product:
        - It asks `ProductResolver.find_match()` for an existing product.
        - If a match exists:
            - `UnitOfWork.add_new_price(...)`
            - `VariationManager.check_for_variation(...)` -> returns a hotlist entry if needed.
            - `UnitOfWork.add_for_update(existing_product)`
        - If no match:
            - `UnitOfWork.add_new_product(...)`
4. After the file loop, `UpdateOrchestrator` calls `UnitOfWork.commit()`.
5. Finally, `UpdateOrchestrator` calls `VariationManager.reconcile_duplicates()` and then `TranslationTableGenerator.generate()`.
