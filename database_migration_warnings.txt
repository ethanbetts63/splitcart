# Database Migration Warnings (SQLite to MySQL)

This file documents the warnings that were identified during the migration from SQLite to MySQL. These issues should be addressed in the future to ensure better data integrity and compatibility with MySQL.

---

## 1. Unique CharField max_length limitation

**Warning:**
`products.Product.normalized_name_brand_size: (mysql.W003) MySQL may not allow unique CharFields to have a max_length > 255.`

**Issue:**
The `normalized_name_brand_size` field in the `Product` model is a `CharField` with `max_length=500` and `unique=True`. Some MySQL configurations have a limit on the length of indexed fields (often 255 characters for `varchar` fields with utf8mb4 encoding).

**Resolution (2025-11-01):** The `max_length` of the `normalized_name_brand_size` field in the `Product` model was reduced from 500 to 255 characters to comply with MySQL's indexing limitations for unique CharFields. This change was made after confirming that potential data truncation was an acceptable risk.

**Implication:**
The `unique` constraint on this field may not be enforced at the database level. This could lead to duplicate values in the `normalized_name_brand_size` column, which could cause unexpected behavior in the application as this field is relied upon for uniqueness.

**Potential Solutions:**
- **Reduce `max_length`**: If possible, reduce the `max_length` of the field to 255 or less. This may not be feasible if the normalized strings can be longer.
- **Use a hash field for uniqueness**: Create a new field that stores a hash (e.g., SHA-256) of the `normalized_name_brand_size` string. This hash field would have a fixed length and could be used for the unique constraint. The application would need to be updated to compute and store the hash.
- **Rely on modern MySQL features**: Newer versions of MySQL with `innodb_large_prefix` enabled might handle this correctly, but it's not guaranteed across all environments.

---

## 2. Conditional Unique Constraints

**Warnings:**
- `account.EmailAddress: (models.W036) MySQL does not support unique constraints with conditions.`
- `products.Product: (models.W036) MySQL does not support unique constraints with conditions.`
- `users.Cart: (models.W036) MySQL does not support unique constraints with conditions.`

**Issue:**
The `Product`, `Cart`, and `EmailAddress` models use conditional unique constraints (e.g., `UniqueConstraint(..., condition=Q(...))`). This feature is used to enforce uniqueness only for a subset of rows that match a certain condition. MySQL does not support these conditions in unique constraints.

**Affected Constraints:**
- **`products.Product`**:
  - `unique_barcode_if_not_null_or_empty`: `barcode` must be unique if it's not null or empty.
    - **Resolution (2025-11-01):** The `barcode` field in the `Product` model was updated to `unique=True, null=True`. This relies on data preparation ensuring that empty string barcodes are converted to `NULL` before being saved to the database. The corresponding `UniqueConstraint` was removed from `Meta.constraints`.
  - `unique_normalized_name_brand_size`: `normalized_name_brand_size` must be unique if it's not null.
    - **Resolution (2025-11-01):** The `normalized_name_brand_size` field in the `Product` model already had `unique=True, null=True`. The corresponding `UniqueConstraint` was removed from `Meta.constraints`, as the field definition itself provides the desired database-level uniqueness for non-null values.
- **`users.Cart`**:
  - `unique_active_user_cart`: A user can only have one active cart.
  - `unique_active_anonymous_cart`: An anonymous user can only have one active cart.
  - **Resolution (2025-11-01):** The `Cart.save()` method was overridden to enforce this constraint at the application level. When a cart is saved as active, the method now deactivates any other active carts for the same user or anonymous session, preventing duplicates.
- **`account.EmailAddress`**: This is from the `django-allauth` package and is a known issue.

**Implication:**
These uniqueness rules are not being enforced at the database level. The responsibility for enforcing this logic falls entirely on the application code. While the application might handle this correctly, it's generally less robust than a database-level guarantee.

**Potential Solutions:**
- **Application-level validation**: Review and enhance the application logic (e.g., in model `clean()` methods or forms) to ensure it prevents the creation of duplicate records that would violate these conditions.
- **Database schema workarounds**: For some cases, it's possible to restructure the data or use triggers to simulate conditional uniqueness in MySQL, but this can be complex.
- **`django-allauth`**: For the `EmailAddress` model, this warning can generally be ignored, as the package has its own application-level logic to ensure email uniqueness.
