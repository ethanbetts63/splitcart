### Grouping and Maintenance Strategy

This document outlines the "bottom-up" strategy for creating and maintaining store groups based on price matching.

#### 1. Core Philosophy & Terminology

The system is designed around a "bottom-up" approach. Every store always belongs to a group, starting in a group of one. Groups are then merged as price matches are confirmed.

*   **Group:** A set of one or more stores confirmed to have matching prices.
*   **Anchor:** Each `Group` has one `Anchor` store. This store is the single "source of truth" for the group's prices. All comparisons are made against the `Anchor`. The Anchor can never be ejected. 
*   **Member:** Any store belonging to a `Group`.
*   **Current Pricing:** For the purpose of internal group health checks (ejections), price data is considered "Current" if it was scraped within the last 7 days. This is a critical rule to ensure comparisons are "apples-to-apples" before breaking up an established group. This rule does not apply to the merging of different groups.
*   **Scrape Scheduling: The scrape schedular does not know anything about group merging. It first checks for stores that have never been scraped, then it checks for stores that have been flagged, then if neither of those checks are fruitful it picks the store with the most stale data. 

#### 2. Initial State: The `cluster_stores` Command

The system is initialized using a simplified `cluster_stores` command. This command will first delete all existing `StoreGroup` objects. Then, it will iterate through every `Store` in the database and create a new, dedicated `StoreGroup` for each one, setting that store as its own `Anchor`.

#### 3. The Update & Comparison Cycle

The core logic is executed at the end of the `update --products` command, after all new prices for the run have been saved. The process is split into two distinct phases:

**Phase 1: Internal Group Maintenance (Health Checks)**

This phase ensures that existing groups remain accurate.

1.  The system identifies all `Groups` with more than one `Member`.
2.  For each `Group`, it checks if the `Anchor` and at least one other `Member` both have "Current Pricing".
3.  If they do, an **Internal Comparison** is performed, comparing the `Member`'s prices against the `Anchor`'s prices.
    *   **If they match:** The `Member` is confirmed as healthy.
        *   To conserve database space, all `Price` objects for the healthy `Member` are then deleted, as they are now considered redundant copies of the `Anchor`'s prices.
    *   **If they do not match:** The `Member` is ejected from the `Group` and placed into a new `Group` of one, becoming its own `Anchor`.
4.  A special case exists for stale data: Before checking any members, the system first verifies if the `Anchor` itself has "Current Pricing". If it does not, the entire group is skipped for the current run, and the `Anchor` store is flagged for a high-priority re-scrape. This prevents any wasteful comparisons against out-of-date anchor data.

**Phase 2: Inter-Group Merging**

This phase grows the groups by finding new matches.

1.  After the maintenance phase is complete, the system finds all `Groups` whose `Anchor` has any price data at all, regardless of its age.
2. An **Intergroup Comparison** is performed, comparing every `Anchor` against every other `Anchor` within the same company.
3.  If two `Anchor`s are found to have matching prices, their `Groups` are merged. The `Group` with fewer members is merged into the one with more members. When this happens, all `Price` objects for all stores in the smaller group are deleted. The old, smaller group is then deactivated.

#### 4. Caching for Performance

To prevent redundant, expensive price comparisons on every run, the system utilizes two caching mechanisms, both with a 7-day cooldown period.

*   **Internal Health Check Cache:** When a `Member` store is successfully health-checked against its `Anchor` and confirmed to be a match, it is recorded in a cache. For the next 7 days, the system will automatically skip health checks for this specific member, assuming it remains healthy.

*   **Inter-Group Comparison Cache:** When two `Anchor` stores are compared and found to **not** be a match, this non-match is recorded in a separate cache. For the next 7 days, the system will automatically skip comparing this specific pair of anchors, focusing only on pairs that have not been recently checked.

*   **In-Memory Price Data Pre-fetching:** To further optimize performance, relevant price data for all stores involved in a comparison pass (for inter-group merging) or within a specific group (for internal health checks) is now fetched into an in-memory cache at the beginning of the process. This eliminates repeated database queries during the comparison loops, allowing the `PriceComparer` to operate on fast, in-memory data.

C:\Users\ethan\coding\splitcart\data_management\database_updating_classes\internal_group_health_checker.py
C:\Users\ethan\coding\splitcart\data_management\database_updating_classes\group_maintenance_orchestrator.py
C:\Users\ethan\coding\splitcart\data_management\database_updating_classes\intergroup_comparer.py
C:\Users\ethan\coding\splitcart\companies\models\store_group.py
C:\Users\ethan\coding\splitcart\companies\models\store_group_membership.py
C:\Users\ethan\coding\splitcart\companies\models\store.py