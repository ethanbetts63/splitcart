# Product Update V2 - Refactoring Plan (v5)

This plan is designed around three core goals:
1.  **Database Integrity**: All changes for a given store are committed in a single, atomic transaction.
2.  **Speed**: Minimize database lookups through smart caching and use bulk operations for all writes.
3.  **Simplicity**: Each class has a clear, single responsibility.

## Core Principle 1: The Dynamic Cache

The process revolves around two types of caches:

*   **Global Caches**: Master in-memory caches for data shared across all stores. These are built **once** at the start of the entire run and are dynamically updated as new products are created. This includes:
    *   A cache of all product barcodes.
    *   A cache of all `normalized_name_brand_size` strings.
    *   A cache of company-specific SKUs.
*   **Per-File Caches**: Temporary caches built at the start of each file's processing cycle and then discarded. This includes:
    *   A cache of all existing `Price` objects for the specific store being processed.

The overall flow is: `Build Global Caches -> For each file: (Build Per-File Caches -> Process Data -> Commit & Update Global Caches) -> Repeat`.

## Core Principle 2: Order of Operations

To ensure database integrity, all database writes within the transaction will follow a strict order. The `UnitOfWork` will execute queries in this sequence:
1.  **DELETE**: Bulk delete stale prices.
2.  **UPDATE**: Bulk update existing products and prices.
3.  **CREATE**: Bulk create new products and prices.

## Class Structure and Workflow

### 1. `UpdateOrchestrator` (The Conductor)
This is the main entry point. It initializes the global caches once. For each file in the inbox, it orchestrates the process:
- Instantiates a `FileReader`, `ProductResolver`, `DictToObjectMapper`, `ProductEnricher`, and `UnitOfWork`.
- Uses `FileReader` to get a list of product data.
- Passes the data and global caches to the `ProductResolver` to get two lists: `raw_data_for_create` and `(existing_product, raw_data_for_update)` tuples.
- Passes `raw_data_for_create` to the `DictToObjectMapper` to get a list of new `Product` instances.
- Passes `(existing_product, raw_data_for_update)` tuples to the `ProductEnricher` to get a list of updated `Product` instances.
- Populates the `UnitOfWork` with these two lists of `Product` instances (and other related data like prices).
- Calls `UnitOfWork.commit()`, which saves all changes for the file in one transaction and updates the global caches.
- Deletes the processed file.

### 2. `FileReader` (The Parser)
A new, simple class with one job:
- Reads a `.jsonl` file.
- Consolidates the data into a list of unique product data dictionaries.
- Returns this list.

### 3. `ProductResolver` (The Matchmaker)
This class is instantiated per file and has a single, focused responsibility.
- It receives the list of product data from the `FileReader` and the global caches.
- It iterates through the incoming products and attempts to find a match in the database using the global caches and a strict 3-tier logic:
    1.  **Tier 1: Barcode**: The highest priority match.
    2.  **Tier 2: SKU**: Must be unique *within the product's company*.
    3.  **Tier 3: `normalized_name_brand_size`**: The fallback identifier.
- It returns two lists: `raw_data_for_create` (list of dictionaries) and `raw_data_for_update` (list of `(existing_product_object, incoming_data_dict)` tuples). It does not interact with the database directly.

### 4. `DictToObjectMapper` (The New Product Factory)
A new, highly focused class:
- **Input**: A list of raw data dictionaries for products to be created.
- **Job**: Converts each dictionary into a new, unsaved `Product` model instance.
- **Output**: A list of `Product` instances ready for `bulk_create`.

### 5. `ProductEnricher` (The Existing Product Updater)
This class is instantiated per file and has a single, focused responsibility.
- **Input**: A list of `(existing_product_object, incoming_data_dict)` tuples.
- **Job**: Iterates through the tuples, compares the incoming data with the existing product object, and updates the product object's attributes *in memory* if changes are detected.
- **Output**: A list of `Product` instances (with `pk`s) that have been modified and are ready for `bulk_update`. Only products that actually changed are included.

### 6. `UnitOfWork` (The Transaction Manager)
This class collects all proposed database changes for a single file.
- It receives the lists of `Product` instances for creation (from `DictToObjectMapper`) and for updating (from `ProductEnricher`).
- It has internal lists for `prices_to_create`, `prices_to_update`, and `prices_to_delete`.
- It works with a `CategoryManager` and `VariationManager` to handle related data.
- Its `commit()` method executes all collected changes in the correct order within a single atomic transaction.

### 7. `CategoryManager` & `VariationManager`
These services will be used by the `UnitOfWork` to handle category and variation logic. They will collect data during the main processing and execute their own bulk database operations within the `UnitOfWork.commit()` transaction, ensuring atomicity.
