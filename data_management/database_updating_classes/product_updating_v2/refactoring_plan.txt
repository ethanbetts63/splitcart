# Product Update V2 - Refactoring Plan (v6)

This plan is designed around three core goals:
1.  **Database Integrity**: All changes for a given store are committed in a single, atomic transaction.
2.  **Speed**: Minimize database lookups through smart caching and use bulk operations for all writes.
3.  **Simplicity**: Each class has a clear, single responsibility.

## Core Principle 1: The Dynamic Cache

The process revolves around two types of caches:

*   **Global Caches**: Master in-memory caches for data shared across all stores. These are built **once** at the start of the entire run and are dynamically updated as new products are created. This includes:
    *   A cache of all product barcodes.
    *   A cache of all `normalized_name_brand_size` strings.
    *   A cache of company-specific SKUs.
*   **Per-File Caches**: Temporary caches built at the start of each file's processing cycle and then discarded. This includes:
    *   A cache of all existing `Price` objects for the specific store being processed.

The overall flow is: `Build Global Caches -> For each file: (Build Per-File Caches -> Process Data -> Commit & Update Global Caches) -> Repeat`.

## Core Principle 2: Order of Operations

To ensure database integrity, all database writes within the transaction will follow a strict order. The `UnitOfWork` will execute queries in this sequence:
1.  **DELETE**: Bulk delete stale prices.
2.  **UPDATE**: Bulk update existing products and prices.
3.  **CREATE**: Bulk create new products and prices.

## Class Structure and Workflow

### 1. `UpdateOrchestrator` (The Conductor)
This is the main entry point. It initializes the global caches once. For each file in the inbox, it orchestrates the process:
- Instantiates all necessary services: `FileReader`, `ProductResolver`, `ProductEnricher`, `DictToObjectMapper`, and `UnitOfWork`.
- Uses `FileReader` to get a list of product data.
- Passes the data and global caches to the `ProductResolver` to get two lists: `raw_data_for_create` and `(existing_product, raw_data_for_update)` tuples.
- Passes the update tuples to the `ProductEnricher` to get a list of "merged" dictionaries for products that need updating.
- Passes both the `raw_data_for_create` list and the "merged" list to the `DictToObjectMapper` to get final lists of `Product` model instances.
- Populates the `UnitOfWork` with these lists of `Product` instances and their corresponding price data.
- Calls `UnitOfWork.commit()`, which saves all changes for the file in one transaction and updates the global caches.
- Deletes the processed file.

### 2. `FileReader` (The Parser)
A simple class with one job:
- Reads a `.jsonl` file and consolidates the data into a list of unique product data dictionaries.

### 3. `ProductResolver` (The Matchmaker)
A per-file class with a single, focused responsibility.
- Receives product data from the `FileReader` and the global caches.
- Uses a strict 3-tier logic (Barcode > SKU > normalized string) to find matches.
- Returns two lists: `raw_data_for_create` (list of dictionaries) and `raw_data_for_update` (list of `(existing_product_object, incoming_data_dict)` tuples).

### 4. `ProductEnricher` (The Data Merger)
A class focused on data-level merging.
- **Input**: A list of `(existing_product_object, incoming_data_dict)` tuples.
- **Job**: Compares the incoming data with the existing product. If changes are detected, it produces a new dictionary representing the final, merged state of the product, including its `pk`.
- **Output**: A list of "merged" dictionaries for only the products that actually need updating.

### 5. `DictToObjectMapper` (The Central Factory)
The universal object creator.
- **Input**: Two lists of dictionaries: one for new products (from `Resolver`) and one for updated products (from `Enricher`).
- **Job**: Converts both lists of dictionaries into lists of `Product` model instances.
- **Output**: Two lists of `Product` objects, one ready for `bulk_create` and one ready for `bulk_update`.

### 6. `UnitOfWork` (The Transaction Manager)
This class collects all proposed database changes for a single file.
- It receives the final lists of `Product` instances for creation and updating.
- It also collects all related price data.
- Its `commit()` method executes all collected changes in the correct order within a single atomic transaction.

### 7. `CategoryManager` & `VariationManager`
These services will be used by the `UnitOfWork` to handle category and variation logic, executing their own bulk database operations within the main `commit()` transaction.