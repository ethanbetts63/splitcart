# Product Update V2 - Refactoring Plan (v7)

This plan is designed around three core goals:
1.  **Clarity and Simplicity**: Each "Manager" class has a clear, single responsibility for its data domain (e.g., Brands, Products).
2.  **Speed**: Minimize database lookups through smart, shared caching and use bulk operations for all database writes.
3.  **Encapsulation**: Each Manager handles its own logic end-to-end, from data processing to database persistence.

## Core Principle 1: Shared, Dynamic Caches

The process revolves around a central set of shared, in-memory caches owned by the `UpdateOrchestrator`.
- **Global Caches**: Built once at the start of the run and dynamically updated by the Managers. This includes caches for products, brands, etc.
- **Cache Integrity**: The `UpdateOrchestrator` ensures that Managers are called in the correct order, so a manager always has access to caches that have been updated by the previous manager in the sequence.

## Core Principle 2: Manager-Led Transactions

We are moving away from a single transaction per file. Instead, each Manager is responsible for its own database writes and will perform them in its own transaction(s). This simplifies the logic within each manager. For example, the `BrandManager` will commit new brands before the `ProductManager` begins its work.

## Class Structure and Workflow

### 1. `UpdateOrchestrator` (The Conductor and State Holder)
This is the main entry point for the update process.
- **Responsibilities**:
    - Initializes the shared global caches (brands, products, etc.).
    - Instantiates the domain-specific managers (`BrandManager`, `ProductManager`, etc.), giving them access to the shared caches.
    - For each file, it calls the managers in the correct order of dependency to process the file's data.
    - Provides methods for the managers to update the shared caches after they have performed database writes.

### 2. `FileReader` (The Parser)
A simple utility class with one job:
- Reads a `.jsonl` file and consolidates the data into a list of unique product data dictionaries.

### 3. `BrandManager` (The Brand Service)
A self-contained service for handling all `ProductBrand` logic.
- **Input**: Raw product data from the `FileReader` and access to the shared caches.
- **Job (Step-by-Step)**:
    1.  **Identify New Brands**: Iterates through the raw data, extracts the `normalized_brand` for each product, and collects any brand names not present in the shared `normalized_brand_names` cache into a temporary set.
    2.  **Prepare Objects**: If new brand names were found, it loops through the set and creates a list of unsaved `ProductBrand` model instances.
    3.  **Persist to DB**: It performs a `ProductBrand.objects.bulk_create()` with the list of new objects, saving them all to the database in a single, atomic transaction.
    4.  **Update Cache**: After creation, it re-fetches the newly created brands from the database to get their database-assigned IDs. It then calls the `cache_updater` from the `UpdateOrchestrator` to add these complete objects to the shared `normalized_brand_names` cache.

### 4. `ProductManager` (The Product Service)
A self-contained service for handling all `Product` logic.
- **Input**: Raw product data and access to the shared caches (which now include any new brands from the `BrandManager`).
- **Job (Step-by-Step)**:
    1.  **Resolve Products**: Iterates through the raw data and uses a 3-tier matching logic (barcode -> SKU -> normalized string) against the shared product caches to sort all items into internal "create" and "update" lists.
    2.  **Prepare Objects**: It processes both lists to create the final objects for the database.
        - For the "create" list, it maps the raw dictionaries to new, unsaved `Product` instances, ensuring to link the `brand` by looking up the brand object in the now-complete shared brand cache.
        - For the "update" list, it runs enrichment logic on each `(existing_product, new_data)` pair, modifying the `existing_product` object in memory and keeping only those that have actually changed.
    3.  **Persist to DB**: It performs `Product.objects.bulk_create()` and `Product.objects.bulk_update()` for the prepared lists of objects, all within a single, atomic transaction.
    4.  **Update Cache**: After the transaction, it re-fetches the newly created products to get their IDs and then updates all the shared product caches (`products_by_barcode`, `products_by_norm_string`, etc.) with the new and updated product information.

### 5. `PriceManager` (Future Service)
A future service that will follow the same pattern. It will be called after the `ProductManager` and will use the updated product cache to handle all price creation, updates, and deletions.
