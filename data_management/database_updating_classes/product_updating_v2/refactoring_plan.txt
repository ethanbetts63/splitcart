# Product Update V2 - Refactoring Plan (v7)

This plan is designed around three core goals:
1.  **Clarity and Simplicity**: Each "Manager" class has a clear, single responsibility for its data domain (e.g., Brands, Products).
2.  **Speed**: Minimize database lookups through smart, shared caching and use bulk operations for all database writes.
3.  **Encapsulation**: Each Manager handles its own logic end-to-end, from data processing to database persistence.

## Core Principle 1: Shared, Dynamic Caches

The process revolves around a central set of shared, in-memory caches owned by the `UpdateOrchestrator`.
- **Global Caches**: Built once at the start of the run and dynamically updated by the Managers. This includes caches for products, brands, etc.
- **Cache Integrity**: The `UpdateOrchestrator` ensures that Managers are called in the correct order, so a manager always has access to caches that have been updated by the previous manager in the sequence.

## Core Principle 2: Manager-Led Transactions

We are moving away from a single transaction per file. Instead, each Manager is responsible for its own database writes and will perform them in its own transaction(s). This simplifies the logic within each manager. For example, the `BrandManager` will commit new brands before the `ProductManager` begins its work.

## Class Structure and Workflow

### 1. `UpdateOrchestrator` (The Conductor and State Holder)
This is the main entry point for the update process.
- **Responsibilities**:
    - Initializes the shared global caches (brands, products, etc.).
    - Instantiates the domain-specific managers (`BrandManager`, `ProductManager`, etc.), giving them access to the shared caches.
    - For each file, it calls the managers in the correct order of dependency to process the file's data.
    - Provides methods for the managers to update the shared caches after they have performed database writes.

### 2. `FileReader` (The Parser)
A simple utility class with one job:
- Reads a `.jsonl` file and consolidates the data into a list of unique product data dictionaries.

### 3. `BrandManager` (The Brand Service)
A self-contained service for handling all `ProductBrand` logic.
- **Input**: Raw product data from the `FileReader` and access to the shared caches.
- **Job**:
    - Identifies all unique brands from the input data.
    - Compares them against the shared brand cache to find new or updated brands.
    - Performs its own database operations (`bulk_create`, `bulk_update`) for brands within its own transaction.
    - After committing to the database, it updates the shared brand cache via a method on the `UpdateOrchestrator`.

### 4. `ProductManager` (The Product Service)
A self-contained service for handling all `Product` logic.
- **Input**: Raw product data and access to the shared caches (which now include any new brands from the `BrandManager`).
- **Job**:
    - Contains the logic for resolving, enriching, and mapping product data (conceptually, it replaces the old `Resolver`, `Enricher`, and `Mapper`).
    - Identifies products to be created and updated.
    - Performs its own database operations (`bulk_create`, `bulk_update`) for products within its own transaction.
    - After committing, it updates the shared product caches.

### 5. `PriceManager` (Future Service)
A future service that will follow the same pattern. It will be called after the `ProductManager` and will use the updated product cache to handle all price creation, updates, and deletions.
