import os
import sys
from datetime import datetime, timedelta
from django.conf import settings

# Define the path to the cache file
CACHE_FILE_PATH = os.path.join(settings.BASE_DIR, 'data_management', 'data', 'group_comparison_cache.py')

class ComparisonCacheManager:
    """
    Manages a file-based cache to avoid re-comparing store groups unnecessarily.
    """
    def __init__(self, command, cooldown_days=7):
        self.command = command
        self.cooldown_period = timedelta(days=cooldown_days)
        self.cache = self._load_and_prune()

    def _load_and_prune(self):
        """
        Loads the cache from the file and removes any entries older than the cooldown period.
        """
        # Ensure the cache file and its directory exist
        os.makedirs(os.path.dirname(CACHE_FILE_PATH), exist_ok=True)
        if not os.path.exists(CACHE_FILE_PATH):
            self._write_cache_file({}) # Create an empty cache file
        
        # Dynamically import the cache file
        sys.path.insert(0, os.path.dirname(CACHE_FILE_PATH))
        try:
            from group_comparison_cache import COMPARISON_CACHE
            # Create a copy to avoid modifying the imported module directly
            cache_data = dict(COMPARISON_CACHE)
        except (ImportError, SyntaxError):
            self.command.stderr.write(self.command.style.ERROR("Could not load or parse comparison cache file. Starting with an empty cache."))
            cache_data = {}
        finally:
            # Clean up sys.path
            if os.path.dirname(CACHE_FILE_PATH) in sys.path:
                sys.path.remove(os.path.dirname(CACHE_FILE_PATH))

        pruned_cache = {}
        now = datetime.now()
        
        for key, timestamp_str in cache_data.items():
            try:
                timestamp = datetime.fromisoformat(timestamp_str)
                if now - timestamp < self.cooldown_period:
                    pruned_cache[key] = timestamp_str
            except (ValueError, TypeError):
                continue # Ignore invalid entries

        pruned_count = len(cache_data) - len(pruned_cache)
        if pruned_count > 0:
            self.command.stdout.write(f"  - Pruned {pruned_count} expired entries from comparison cache.")

        return pruned_cache

    def _get_key(self, group_a_id: int, group_b_id: int) -> str:
        """Creates a consistent, sorted key for a pair of group IDs."""
        return "-".join(map(str, sorted([group_a_id, group_b_id])))

    def should_skip(self, group_a_id: int, group_b_id: int) -> bool:
        """Checks if a comparison for a given pair of groups is within the cooldown period."""
        key = self._get_key(group_a_id, group_b_id)
        return key in self.cache

    def record_comparison(self, group_a_id: int, group_b_id: int):
        """Adds or updates a comparison record with the current timestamp."""
        key = self._get_key(group_a_id, group_b_id)
        self.cache[key] = datetime.now().isoformat()

    def _write_cache_file(self, cache_data: dict):
        """Writes the given dictionary to the cache file."""
        try:
            with open(CACHE_FILE_PATH, 'w', encoding='utf-8') as f:
                f.write("# This file is auto-generated by the ComparisonCacheManager. Do not edit manually.\n")
                f.write("COMPARISON_CACHE = {\n")
                # Sort keys for consistent file output
                for key in sorted(cache_data.keys()):
                    f.write(f"    '{key}': '{cache_data[key]}',\n")
                f.write("}\n")
        except IOError as e:
            self.command.stderr.write(self.command.style.ERROR(f"CRITICAL: Could not write to cache file: {e}"))

    def save(self):
        """Saves the current in-memory cache back to the file."""
        self.command.stdout.write("  - Saving updated comparison cache to file...")
        self._write_cache_file(self.cache)
        self.command.stdout.write(self.command.style.SUCCESS("  - Cache saved."))
