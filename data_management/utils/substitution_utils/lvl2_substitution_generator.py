from itertools import combinations
from .substitution_generator import BaseSubstitutionGenerator
from products.models import Product, ProductBrand
from thefuzz import fuzz
from .size_comparer import SizeComparer

class Lvl2SubstitutionGenerator(BaseSubstitutionGenerator):
    """
    Generates substitutions for Level 2: Same brand, similar product.
    This implementation now uses string similarity on normalized names to group products.
    """
    def generate(self):
        level_definition = "Same brand, similar product, similar size."
        self.command.stdout.write(f"--- Generating Level 2: {level_definition} ---")
        
        size_comparer = SizeComparer()
        brands = ProductBrand.objects.all()
        new_substitutions_count = 0

        for brand in brands:
            # Eagerly load products to avoid N+1 queries
            products = list(Product.objects.filter(brand__name=brand.name))
            if len(products) < 2:
                continue

            # Group products by similarity of their normalized names
            similar_product_groups = self._group_by_similarity(products)

            for group in similar_product_groups:
                if len(group) > 1:
                    # Create substitutions for all pairs within the group
                    for prod_a, prod_b in combinations(group, 2):
                        if size_comparer.are_sizes_compatible(prod_a, prod_b):
                            _, created = self._create_substitution(
                                prod_a, prod_b, level='LVL2', score=0.95, source='size_similarity_v1'
                                )                        
                            if created:
                                new_substitutions_count += 1
        
        self.command.stdout.write(self.command.style.SUCCESS(f"Generated {new_substitutions_count} new Level 2 substitutions."))

    def _group_by_similarity(self, products):
        """
        Groups products by comparing the similarity of their normalized_name.
        This uses a clustering approach with a high similarity threshold.
        """
        groups = []
        for product in products:
            # The product's normalized_name is the key for comparison.
            # This field is generated by the model's save() method.
            if not product.normalized_name:
                continue

            placed_in_group = False
            for group in groups:
                # Compare the new product to the first product in an existing group.
                representative = group[0]
                
                # token_set_ratio is robust against different word order and extra words.
                similarity_score = fuzz.token_set_ratio(
                    product.normalized_name, 
                    representative.normalized_name
                )
                
                # A high threshold is used to ensure we're only grouping clear size variants.
                if similarity_score > 90 and similarity_score < 100:
                    group.append(product)
                    placed_in_group = True
                    break
            
            if not placed_in_group:
                # This product becomes the representative for a new group.
                groups.append([product])
        return groups
