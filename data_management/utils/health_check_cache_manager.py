import os
import sys
from datetime import datetime, timedelta
from django.conf import settings

# Define the path to the cache file
CACHE_FILE_PATH = os.path.join(settings.BASE_DIR, 'data_management', 'data', 'health_check_cache.py')

class HealthCheckCacheManager:
    """
    Manages a file-based cache to avoid re-running health checks on healthy members.
    """
    def __init__(self, command, cooldown_days=7):
        self.command = command
        self.cooldown_period = timedelta(days=cooldown_days)
        self.cache = self._load_and_prune()

    def _load_and_prune(self):
        """
        Loads the cache from the file and removes any entries older than the cooldown period.
        """
        os.makedirs(os.path.dirname(CACHE_FILE_PATH), exist_ok=True)
        if not os.path.exists(CACHE_FILE_PATH):
            self._write_cache_file({})

        sys.path.insert(0, os.path.dirname(CACHE_FILE_PATH))
        try:
            from health_check_cache import HEALTH_CHECK_CACHE
            cache_data = dict(HEALTH_CHECK_CACHE)
        except (ImportError, SyntaxError):
            self.command.stderr.write(self.command.style.ERROR("Could not load or parse health check cache file. Starting with an empty cache."))
            cache_data = {}
        finally:
            if os.path.dirname(CACHE_FILE_PATH) in sys.path:
                sys.path.remove(os.path.dirname(CACHE_FILE_PATH))

        pruned_cache = {}
        now = datetime.now()
        
        for store_id_str, timestamp_str in cache_data.items():
            try:
                timestamp = datetime.fromisoformat(timestamp_str)
                if now - timestamp < self.cooldown_period:
                    pruned_cache[store_id_str] = timestamp_str
            except (ValueError, TypeError):
                continue

        pruned_count = len(cache_data) - len(pruned_cache)
        if pruned_count > 0:
            self.command.stdout.write(f"  - Pruned {pruned_count} expired entries from health check cache.")

        return pruned_cache

    def should_skip(self, member_store_id: int) -> bool:
        """Checks if a health check for a given member is within the cooldown period."""
        key = str(member_store_id)
        return key in self.cache

    def record_healthy_member(self, member_store_id: int):
        """Adds or updates a healthy member record with the current timestamp."""
        key = str(member_store_id)
        self.cache[key] = datetime.now().isoformat()

    def _write_cache_file(self, cache_data: dict):
        """Writes the given dictionary to the cache file."""
        try:
            with open(CACHE_FILE_PATH, 'w', encoding='utf-8') as f:
                f.write("# This file is auto-generated by the HealthCheckCacheManager. Do not edit manually.\n")
                f.write("HEALTH_CHECK_CACHE = {\n")
                for key in sorted(cache_data.keys(), key=int): # Sort numerically
                    f.write(f"    '{key}': '{cache_data[key]}',\n")
                f.write("}\n")
        except IOError as e:
            self.command.stderr.write(self.command.style.ERROR(f"CRITICAL: Could not write to health check cache file: {e}"))

    def save(self):
        """Saves the current in-memory cache back to the file."""
        self.command.stdout.write("  - Saving updated health check cache to file...")
        self._write_cache_file(self.cache)
        self.command.stdout.write(self.command.style.SUCCESS("  - Health check cache saved."))
