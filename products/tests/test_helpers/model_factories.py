import factory
from factory.django import DjangoModelFactory
from products.models import Product, Price, ProductBrand, ProductSubstitution, PriceRecord
from companies.tests.test_helpers.model_factories import StoreFactory

class ProductFactory(DjangoModelFactory):
    class Meta:
        model = Product

    name = factory.Faker('word')
    brand = factory.SubFactory('products.tests.test_helpers.model_factories.ProductBrandFactory')
    size = factory.Faker('word')
    barcode = factory.Sequence(lambda n: f'123456789012{n}')
    image_url = factory.Faker('image_url')
    url = factory.Faker('url')
    description = factory.Faker('text')
    country_of_origin = factory.Faker('country')
    allergens = factory.Faker('text')
    ingredients = factory.Faker('text')
    normalized_name_brand_size_variations = []
    # category, substitute_goods and size_variants will be handled post-generation for ManyToMany

    @classmethod
    def _create(cls, model_class, *args, **kwargs):
        """
        Override the default _create method to ensure the model's clean() method is called.
        """
        obj = model_class(*args, **kwargs)
        obj.save()
        return obj

class PriceRecordFactory(DjangoModelFactory):
    class Meta:
        model = PriceRecord

    product = factory.SubFactory(ProductFactory)
    price = factory.Faker('pydecimal', left_digits=2, right_digits=2, positive=True)
    was_price = factory.Faker('pydecimal', left_digits=2, right_digits=2, positive=True)
    unit_price = factory.Faker('pydecimal', left_digits=2, right_digits=2, positive=True)
    unit_of_measure = factory.Faker('word')
    is_on_special = factory.Faker('boolean')

class PriceFactory(DjangoModelFactory):
    class Meta:
        model = Price

    price_record = factory.SubFactory(PriceRecordFactory)
    store = factory.SubFactory(StoreFactory)
    sku = factory.Faker('uuid4')
    is_available = factory.Faker('boolean')
    is_active = True
    scraped_date = factory.Faker('date_object')
    normalized_key = factory.Sequence(lambda n: f'key_{n}')

class ProductBrandFactory(DjangoModelFactory):
    class Meta:
        model = ProductBrand

    name = factory.Sequence(lambda n: f'Test Brand {n}')
    # normalized_name is generated by save()

    @classmethod
    def _create(cls, model_class, *args, **kwargs):
        """
        Override the default _create method to allow for manually setting
        the normalized_name field, bypassing the model's save() method logic.
        """
        normalized_name = kwargs.pop('normalized_name', None)
        obj = super()._create(model_class, *args, **kwargs)
        if normalized_name:
            model_class.objects.filter(pk=obj.pk).update(normalized_name=normalized_name)
            obj.refresh_from_db()
        return obj

class ProductSubstitutionFactory(DjangoModelFactory):
    class Meta:
        model = ProductSubstitution

    product_a = factory.SubFactory(ProductFactory)
    product_b = factory.SubFactory(ProductFactory)
    score = factory.Faker('pyfloat', left_digits=1, right_digits=2, positive=True)