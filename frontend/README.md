# SplitCart Frontend

This directory contains the frontend single-page application (SPA) for the SplitCart project.

## Overview

The application is built using React and TypeScript, bootstrapped with Vite. It provides a modern, interactive user interface for users to manage their shopping lists, find the best prices across different stores, and view optimized shopping plans.

## Core Technologies

- **Framework**: [React](https://react.dev/) with [TypeScript](https://www.typescriptlang.org/)
- **Build Tool**: [Vite](https://vitejs.dev/)
- **Styling**: [Tailwind CSS](https://tailwindcss.com/) with [shadcn/ui](https://ui.shadcn.com/) for a utility-first component library.
- **Routing**: [React Router](https://reactrouter.com/) for client-side routing.
- **State Management**: [React Context](https://react.dev/learn/passing-data-deeply-with-context) for global application state.

## Project Structure

```
src/
├── components/   # Reusable UI components (e.g., ProductTile, Button)
├── context/      # Global state providers (AuthContext, CartContext, StoreListContext)
├── hooks/        # Custom React hooks for reusable stateful logic (e.g., useApiQuery)
├── lib/          # Utility functions (e.g., cn for classnames, debounce)
├── pages/        # Top-level components representing application pages
├── services/     # Centralized modules for backend API communication
└── types/        # TypeScript type definitions
```

## Key Architectural Concepts

### State Management

The application's global state is managed via React's Context API, separated by domain:

- **`AuthContext.tsx`**: Manages user authentication state, including JWT tokens and anonymous user IDs.
- **`CartContext.tsx`**: Manages the state of the user's shopping cart, including all items and substitutions. It also orchestrates all actions related to the cart.
- **`StoreListContext.tsx`**: Manages the user's selected stores for price comparison.

### API Interaction

API communication is handled through a dedicated service layer, promoting a clean separation of concerns.

- **`services/apiClient.ts`**: A central `ApiClient` class that wraps `fetch`. It's responsible for automatically attaching authentication headers (`Authorization` token or `X-Anonymous-ID`) and standardizing error handling.
- **`services/*.api.ts`**: Service files (`cart.api.ts`, `storeList.api.ts`) contain functions that encapsulate specific API endpoint calls. These functions use an `ApiClient` instance to perform the request.
- **Pattern**: React Contexts (like `CartContext`) use these service functions to interact with the backend, keeping the data-fetching logic separate from state management logic.

### Cart Logic: Debounced Sync

To create a responsive user experience and reduce server load, cart modifications (`addItem`, `updateItemQuantity`) do not trigger an API call for every change. Instead, they perform an "optimistic update" to the local UI state and then call a **debounced `sync` function**. This function waits for a period of inactivity (e.g., 1.5 seconds) before sending the entire cart state to the backend in a single `/api/carts/sync/` request.

## Search and Ordering Logic

The application provides several options for sorting product lists, with a sophisticated "Bargain-First" system as the default.

### Ordering Options

- **Bargain-First (Default)**: This is the default sorting for category pages. It's a hybrid system designed to surface the best deals in real-time. It works in two main stages:
    1.  **Candidate Identification**: The backend first quickly identifies a list of potential bargain products. It uses a pre-calculated `ProductPriceSummary` table for this, which contains aggregated data like the best possible discount for a product across all stores.
    2.  **On-the-Fly Calculation**: For this smaller list of candidates, the backend performs a live, on-the-fly calculation. It fetches the current prices from the user's selected stores and calculates the *actual* discount percentage. Products with a real discount are shown first, sorted from highest to lowest discount. Products with no discount are then sorted by their best unit price.
- **Search (Default)**: When using the text search bar, results are sorted by a relevance score based on how well the product's name, brand, and size match the search term. Bargain calculations are not applied to search results.
- **Price (Asc/Desc)**: Sorts products by the lowest available price from the user's selected stores.
- **Unit Price (Asc)**: Sorts products by the lowest available unit price (e.g., price per 100g) from the user's selected stores.

### Generating Price Summaries

The first step of the "Bargain-First" logic relies on pre-calculated data. This data is generated by a management command:

```bash
python manage.py generate --price-summaries
```

This command populates the `ProductPriceSummary` table in the database. It iterates through all products and calculates aggregate metrics (like minimum price, maximum price, and the best *possible* discount), which enables the backend to quickly identify potential bargain candidates without having to scan the entire price database for every request.

## Getting Started

1.  **Install Dependencies**:
    ```bash
    npm install
    ```
2.  **Run the Development Server**:
    ```bash
    npm run dev
    ```
    The application will be available at `http://localhost:5173`.
3.  **Build for Production**:
    ```bash
    npm run build
    ```
    The production-ready assets will be generated in the `dist` directory.
